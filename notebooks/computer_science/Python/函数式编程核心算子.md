Python 常见 iterable 函数，本质是把“循环”提升为“语义动词”，
让人读代码时，看到的是“在做什么”，而不是“怎么遍历”。

一句话总览（先给你地图）

Python 常见“以 iterable 为输入”的函数，本质上是：
对序列进行 聚合 / 变换 / 选择 / 控制 的高阶操作。

一、内建函数（最核心、最常用）
1️⃣ 聚合（Aggregation）
函数	语义
sum(it)	求和
min(it)	最小
max(it)	最大
any(it)	∃
all(it)	∀
len(it)	元素个数（⚠️ 不适用于 generator）
2️⃣ 变换（Transformation）
函数	说明
map(f, it)	映射
zip(it1, it2, ...)	并行组合
enumerate(it)	加索引
3️⃣ 选择 / 过滤（Selection）
函数	说明
filter(f, it)	条件筛选
itertools.compress(data, selectors)	按布尔掩码
4️⃣ 排序 / 重排
函数	说明
sorted(it)	排序（返回 list）
reversed(it)	反向迭代
heapq.nlargest / nsmallest	局部排序
二、itertools（这是“迭代器工具箱”，非常 Pythonic）
1️⃣ 生成 / 组合
函数	语义
chain(it1, it2, ...)	串联
product(it1, it2)	笛卡尔积
permutations(it)	排列
combinations(it, r)	组合
2️⃣ 切片 / 控制
函数	语义
islice(it, start, stop, step)	惰性切片
takewhile(f, it)	前缀
dropwhile(f, it)	跳过前缀
3️⃣ 分组 / 累积
函数	语义
groupby(it, key)	分组
accumulate(it)	累积
三、容器 / 构造器（消费 iterable）
函数	结果
list(it)	list
tuple(it)	tuple
set(it)	set
dict(it)	dict（接收 (k, v)）
四、字符串 & 文件（本质也是 iterable）
对象	可迭代性
str	字符流
file	行流
bytes	字节流

常见用法：

any(line.startswith("#") for line in f)
sum(1 for _ in f)

五、第三方库（概念延伸）
NumPy / Pandas

表面像 iterable

实际是 向量化 / C 层遍历

np.sum(arr)
df.apply(...)

六、一个“心智模型”（你会很适合这个）

可以把它们分成四类 动词：

类别	动词
聚合	reduce
变换	map
选择	filter
控制	take / drop / group

这正是函数式编程的核心算子集合。

这是一个非常成熟、而且是“分界线级”的问题。
我直接给你一个可操作的判断框架，而不是口号。

一句话结论（先记住）

当“过程本身就是问题的一部分”时，
语义上就必须用循环（或等价的递归/状态机）。

不是因为 Python 不支持函数式，
而是因为问题本身是“过程语义”的。

一、什么时候“语义上必须用循环”（核心判断）

下面这 6 类情况，用不用 for 都一样，本质上都需要“循环语义”。

1️⃣ 存在“可变状态随步骤演化”
state = init
for event in events:
    state = update(state, event)
    if state.is_terminal():
        break


👉 状态不是简单的 fold 结果，而是：

有分支

有提前终止

有副作用

这不是 map / reduce 能表达的。

2️⃣ 需要 early break / continue
for x in xs:
    if bad(x):
        break


any / all 可以覆盖一部分

但复杂 break 条件 → 必须循环

3️⃣ 循环体内有多分支控制流
for token in tokens:
    if token.type == A:
        ...
    elif token.type == B:
        ...
    else:
        ...


👉 这是一个 状态机 / dispatcher
函数式抽象反而会模糊语义。

4️⃣ 顺序本身有语义意义
for step in steps:
    do(step)


前后顺序影响结果

不只是“对集合做变换”

5️⃣ 有副作用（I/O / 日志 / 资源管理）
for row in rows:
    write_db(row)
    log(row)


用 map(write_db, rows) 是反模式。

6️⃣ 算法本身是“过程型定义”

典型例子：

BFS / DFS

动态规划

模拟 / 仿真

博弈 / 搜索

while frontier:
    node = frontier.pop()
    expand(node)


👉 这类问题，过程就是模型。

二、什么时候“不该用循环”（反向对照）
❌ 循环只是“技术细节”
res = []
for x in xs:
    res.append(f(x))


👉 用 comprehension / map。

❌ 循环只是“判断存在性”
found = False
for x in xs:
    if cond(x):
        found = True
        break


👉 用 any.

❌ 循环只是“聚合”
total = 0
for x in xs:
    total += x


👉 用 sum.

三、一个非常好用的语义判断口诀

如果你在脑中描述问题时，说的是：
“然后……接着……如果……否则……”
那你就已经在描述一个循环过程了。

反过来：

如果你说的是：
“是否存在… / 对每个… / 所有… / 映射为…”
那你在描述集合语义，不该写循环。

四、放到你一直用的“抽象层模型”里
集合层（map/filter/any/all）
  ↑
结构层（groupby / accumulate）
  ↑
过程层（for / while / state machine）  ← 必须循环


循环不是最低级，
循环是“最高语义层的控制结构”。

五、终极一句话总结（你可以直接记这个）

当“步骤、顺序、状态、分支、提前终止”是问题语义的一部分时，
就必须用循环（或等价的递归 / 状态机），
这是对问题的尊重，不是代码退化。