# 最大流：从模型到算法，再到问题结构的深化

## 1. 问题与模型（Problem / Model）

### 最大流问题定义
- 对象：有向图 G = (V, E)
- 每条边 e 有容量 c(e)
- 流 f(e) 满足：
  - 容量约束：0 ≤ f(e) ≤ c(e)
  - 流守恒：除 s, t 外，流入 = 流出
- 目标：最大化从源点 s 流出的总流量 v(f)

👉 这是**问题模型**，与算法无关。

---

## 2. 模型深化：Residual Graph（残量图）

### 残量图 G_f 的含义
- 用来刻画：
  > **在当前流 f 附近，哪些“改动方向”仍然是可行的**

对原图中的边 e = (u → v)：
- forward residual edge：容量 = c(e) − f(e)
- backward residual edge：容量 = f(e)

⚠️ backward 边不是“反向流”，而是**撤销已有流量的操作通道**。

---

## 3. 结构定理（模型层结论）

### 核心事实
> 当前流 f 不是最大流  
> ⇔ 残量图 G_f 中存在一条 s–t 路径（增广路）

这一定理是：
- **问题的结构刻画**
- 不是算法结论

---

## 4. 算法：Ford–Fulkerson

### 算法描述
初始化一个可行流 f
while (G_f 中存在 s–t 路径 P):
f ← augment(f, P)

- augment：沿路径统一推送 bottleneck(P, f)

---

## 5. 算法分析 I：正确性与不变量

### 不变量（Invariant）
- 每一步之后：
  - 流仍然满足容量约束
  - 流仍然满足流守恒
- backward / forward 的组合不会破坏可行性

---

## 6. 算法分析 II：终止性（Algorithm Exists）

### 整数容量假设下
- 所有 residual capacity 为整数
- bottleneck(P, f) ≥ 1
- 每次 augmentation：
  - v(f) 严格增加

### 结论
- v(f) 有有限上界
- while-loop 只能执行有限次
- **算法在有限步内终止**

👉 这一步证明的是：
> **这是一个真正的算法，而不是无限过程**

---

## 7. 算法分析 III：从算法反推问题结构

当算法停止时：
- 残量图中 s 无法到达 t
- 从 s 可达的节点集合 S
- 其余节点集合 T
- (S, T) 构成一个 cut
- 当前流量 = cut 的容量

### 得到结构定理
> **最大流 = 最小割**

⚠️ 注意逻辑方向：
- 不是“因为最小割存在所以算法停”
- 而是“因为算法停了，我们发现了最小割”

---

## 8. 方法论总结（非常重要）

### 模型层 vs 算法层 vs 分析层

- 模型层：
  - 问题是什么？
  - 解具有什么性质？
- 算法层：
  - 如何构造解？
- 算法分析层：
  - 算法为什么正确？
  - 为什么会停？
  - 停下来的状态说明了什么结构？

---

## 9. 核心方法论结论（可长期复用）

> **算法分析不仅是验证算法，  
> 更是一种反向揭示问题结构、深化模型理解的工具。**

或者一句更狠的：

> **好算法，本身就是问题结构的一种“可执行证明”。**

---

## 10. 判断准则（以后读算法可用）

阅读一段算法分析时，问自己：

- 作者是在总结「怎么解一类问题？」  
  → 算法设计范式
- 还是在回答「这个问题本质上是什么结构？」  
  → 模型深化 / 理论发现

最大流这一章，核心是后者。
