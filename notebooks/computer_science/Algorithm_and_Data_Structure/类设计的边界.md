类的边界与设计原则（State-Driven × DDD 视角）
一、类的边界从哪里来？

类的边界不是从“功能”来，而是从：

不变量 + 状态变化责任 + 抽象层级

三个维度决定。

二、第一原则：边界 = 不变量的集合

如果一组数据必须共同保持一致，

它们就应该属于同一个边界。

✅ 正确例子（调度系统）

这些必须同时成立：

pending ∩ completed = ∅

task 只能被分配一次

allocation 合法

resource.available_time 不倒退

这些跨越：

tasks

resources

allocations

因此：

→ 必须存在一个“聚合对象”
→ SystemState

三、第二原则：谁负责改变状态？

类的边界还取决于：

谁拥有改变状态的权力？

如果对象可以随意被外部修改，

边界就不存在。

正确结构：

Policy：只读 state

Planner：通过 state 的合法接口改变 state

外部：不能直接改 list

这叫：

权力集中，边界清晰

四、第三原则：结构对象 vs 行为对象

你现在的系统可以分为两类：

1️⃣ 结构型对象（Structural）

Task

Resource

Allocation

SystemState

它们负责：

表达状态

维护不变量

2️⃣ 行为型对象（Operational）

Policy

Planner

Simulator

它们负责：

决策

转移

演化

五、第四原则：边界必须最小且充分

不要：

把所有东西放进一个大类

也不要把每条规则拆成一个类

边界应当是：

维护一组强一致性所需的最小集合

六、第五原则：不要用“功能分层”来划分类

很多人按：

controller

service

model

划分边界。

这只是工程分层。

真正的类边界应该来自：

状态一致性 + 不变量

七、在你当前系统中的类边界结构
Task

边界理由：

它的参数必须合法

它不参与状态转移

Resource

边界理由：

它是一条时间轴

它只负责自身时间合法性

Allocation

边界理由：

它是一条不可变历史记录

SystemState（聚合）

边界理由：

所有跨对象不变量都在这里

它是合法状态空间 S_valid 的载体

Policy

边界理由：

它定义 π

它不改变状态

Planner

边界理由：

它实现 T

它不拥有状态

八、核心设计公式

你现在的系统可以用一个公式概括：

类边界 = 需要共同维护的不变量集合

九、一个更抽象的理解（你会喜欢）
类不是：

数据 + 方法

类是：

一个局部合法世界

对象的存在，是为了：

限制状态空间

十、极简设计哲学总结

状态属于结构对象

行为属于操作对象

不变量决定边界

聚合定义一致性范围

外部不得绕过边界

十一、与你之前思考的统一

你之前说：

数据结构在定义可能世界

现在升级为：

类边界在定义合法世界

这已经是系统级思维。

十二、下一步建议

我们可以继续深入一个更高级的问题：

👉 类边界是否应该随着算法变化而变化？

这个问题会直接影响你未来：

做 RL

做不确定调度

做多策略实验