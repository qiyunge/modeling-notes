# From Theory → Patterns → Practice: Algorithm Design Notes (v0.1)
（算法：从理论到模式到实践的统一笔记）
> 主题：**状态建模 → 算法选择** 的可落地映射体系

---

## 0. 一句话总纲

算法设计可以被写成一个“工程化公式”：

Algorithm = State Representation + Transition + Constraints + Objective + Search/Compute Strategy


换句话说：

- **你怎么表示状态**（state representation）
- **状态如何变化**（transition）
- **哪些状态有效**（constraints / feasibility）
- **什么算更好**（objective / optimality）
- **用什么策略推进**（search / DP / greedy / optimization）

---

## 1. 理论骨架：从解空间到状态空间

### 1.1 解空间（Solution Space）
解空间 = 所有可能答案的集合（通常巨大，不能直接枚举）

例：
- 排列：所有 permutations
- 子集：所有 subsets
- 路径：所有 path(A→B)
- 参数：所有 parameter combinations

### 1.2 状态空间（State Space）
状态空间 = 生成解的“过程空间”，即“部分解 + 转移规则”构成的图

核心转化：

Solution space (终点集合)
→ State space (通向终点的过程图)


### 1.3 状态图（State Graph）
你可以把任何算法看成：

Nodes = states
Edges = transitions
Goal = accepting states / optimal states
Cost = edge cost or path cost (optional)


---

## 2. 状态建模的最小语言（必须掌握）

当你要建 state，先问四个问题（固定模板）：

1) **Partial solution 是什么？**（我现在已经做了多少）
2) **还缺什么信息才能继续？**（下一步决策需要什么）
3) **哪些信息必须记住？哪些可以推导？**（状态最小化）
4) **状态如何转移？**（transition function）

> 其中第 3 个问题决定复杂度上限。

---

## 3. 状态类型 → 算法选择（核心映射表）

这是你要的“状态建模 → 算法选择”总表。

| 状态形态（你建出来的 state） | 常见特征 | 首选算法族 |
|---|---|---|
| **Prefix / Constructive** | state 是“部分构造结果”，分支多 | DFS / Backtracking + Pruning |
| **Index / Pointer** | state 主要是位置（i/j/l/r），单调推进 | Two Pointers / Sliding Window / Linear Scan |
| **Visited / Subset** | state 包含 visited 或 subset（组合爆炸） | Backtracking / Bitmask DP / BFS over subsets |
| **DAG Subproblem** | state 是子问题，依赖更小索引 | DP（自底向上/记忆化） |
| **Graph Node** | state 是节点或节点+少量信息 | BFS / DFS |
| **Weighted Graph** | 有权重 cost，需要最短/最小代价 | Dijkstra / Bellman-Ford / SPFA（谨慎） |
| **Heuristic Search** | 有目标距离可估计 | A* / Best-first |
| **Monotone Feasibility** | “可行性”随参数单调变化 | Binary Search on answer + Check |
| **Interval / Range** | state 与区间有关 | Interval DP / Segment Tree / Sweep Line |
| **Streaming / Online** | 数据逐步来，不能回看 | One-pass + Invariants / Sketching |
| **Continuous parameters** | 变量连续、目标可优化 | Gradient / Convex optimization / Numerical methods |

> 你真正要练的是：**看到题 → 先写出 state → 再查表选算法**。

---

## 4. Pattern Library：把算法当“模式”使用（可复用模板）

下面把最常用模式写成“识别信号 + state + transition + 典型实现”。

---

### Pattern A: Linear Scan + Hash (O(n) 常胜组合)
**识别信号**
- 要找重复 / 计数 / 是否存在
- 需要快速 membership / frequency

**state**
i (当前位置)
hash map / set (已见信息)


**transition**
- i++
- 更新 set/map

**典型题**
- Contains Duplicate
- Two Sum（hash 版本）
- Longest Consecutive Sequence（hash + 扩展）

---

### Pattern B: Two Pointers
**识别信号**
- 数组/字符串
- 常需要 pair / triplet
- 排序后条件具有“单调性”

**state**
(l, r)


**transition**
- 满足条件：l++ 或 r--
- 根据比较结果单调推进

**典型题**
- Two Sum II（sorted）
- 3Sum（固定 i + (l,r)）
- Container With Most Water

---

### Pattern C: Sliding Window
**识别信号**
- “最长/最短子串/子数组”
- 条件与窗口统计有关（频率、distinct、sum）

**state**
(l, r, windowStats)


**transition**
- 扩张：r++
- 条件不合法则收缩：l++

**关键点**
- windowStats 必须支持 O(1) 更新与合法性判断

---

### Pattern D: Backtracking / DFS Constructive
**识别信号**
- 输出所有方案 / 组合
- 选择分支明显（选/不选，选哪个）
- 约束可以剪枝

**state**
path (partial solution)

used / remaining (optional)


**transition**
- choose
- recurse
- undo (backtrack)

**剪枝来源**
- 约束提前判定
- 排序 + 去重
- 上界估计（branch & bound）

---

### Pattern E: BFS on State Graph
**识别信号**
- 最短步数（每一步代价相同）
- “从起点到终点的最少操作次数”
- 状态可离散化

**state**
node or (node, extraInfo)


**transition**
- 对所有合法操作生成 next state
- visited 防重复

---

### Pattern F: DP as “Subproblem Graph”
**识别信号**
- 最优值 / 方案数
- 子问题重叠
- 状态可按规模排序（i/j/len）

**state**
dp[state]


**transition**
dp[s] = combine(dp[smaller states])


**DP = DAG 上的计算**
- 边：依赖关系
- 拓扑序：计算顺序

---

### Pattern G: Greedy + Invariant
**识别信号**
- 每一步“做出一个不可逆决定”
- 能维护一个不变量（invariant）
- 具有 exchange argument 的直觉

**state**
- 当前局面 + 不变量结构（如 heap / count）

**transition**
- 做局部最优动作
- 更新不变量

> 注意：Greedy 的“难”不在写代码，而在证明正确性。

---

### Pattern H: Binary Search on Answer
**识别信号**
- 问题是“最小满足 / 最大满足”
- 你能写一个 `check(x)` 判断是否可行
- 可行性对 x **单调**

**state**
- mid（候选答案）
- check(mid)

---

## 5. 关键能力：状态最小化（避免爆炸）

### 5.1 两个失败模式
- **state 过大** → 状态数爆炸 → 超时
- **state 过小** → 信息不足 → 无法判定或转移

### 5.2 最小化原则（工程版）
能推导出来的，别存；必须记忆的，才存。

常见“可推导”的信息：
- prefix 的 sum（可增量维护）
- 窗口统计（可增量维护）
- parent（可通过 BFS parent map 还原）

常见“必须存”的信息：
- visited（避免重复）
- dp 值（避免重复计算）
- 多维约束下的关键变量（如 i,j,k）

---

## 6. 从“理论”落到“实战”的统一流程（你刷题就按这个来）

每道题强制走这个 6 步流程：

### Step 1 — 写出输出结构
- 输出是值？集合？路径？最优值？

### Step 2 — 写出解空间形式（哪怕很大）
- 所有组合？所有路径？所有切分？

### Step 3 — 设计 state（部分解）
- state 需要包含哪些信息才能继续？

### Step 4 — 写 transition（下一步生成规则）
- 从 state 怎么得到 next state？

### Step 5 — 标注约束与目标
- constraint：哪些 state 无效？
- objective：最短？最大？计数？

### Step 6 — 查“映射表”选算法族
- BFS / DFS / DP / Greedy / Dijkstra / A* / BinarySearchOnAnswer

---

## 7. 快速对照：目标/代价 → 算法选择

| 目标/代价结构 | 常用算法 |
|---|---|
| 最少步数（每步相同代价） | BFS |
| 最短路径（非负权） | Dijkstra |
| 最短路径（可负权） | Bellman-Ford |
| 最优值 + 子问题重叠 | DP |
| 输出所有方案 | Backtracking |
| 单调可行性 | Binary Search on Answer |
| 有启发式距离 | A* |
| 在线/流式 | One-pass + Invariant |

---

## 8. 实战示例：你说的两点分别对应什么？

### 8.1 “通过什么状态空间找到解空间有效/最有效”
翻译成工程语言：

- **状态表示要让“可行性判断”便宜**
- **状态转移要让“搜索深度/分支”可控**
- **目标要能被代价函数度量**（最短/最小/最大）

好状态空间的三条标准：

1) 可行性：`isValid(state)` 快
2) 转移：`next(state)` 少且可剪枝
3) 最优性：`cost(state)` 可比较（或可 DP）

### 8.2 “算法如何从一个状态到另一个状态，包括状态构建”
翻译：

- state 构建 = 定义“部分解”的数据结构
- transition = 选择动作（action）并更新 state
- visited/memo = 防止重复状态

你已经在用强化学习语言了：

state -> action -> next_state


---

## 9. v0.2 演化（建议）
下一版可以加入两个“真正职业级”的模块：

1) **State Design Error Book（状态建模错误学）**
- 为什么会超时
- 为什么剪枝无效
- 为什么 DP 写不出转移

2) **Proof Kit（正确性证明工具箱）**
- BFS 最短性证明模板
- DP 正确性证明模板（归纳）
- Greedy 交换论证模板

---

## 10. 终极结论（你可以写进你的世界观）

算法不是技巧集合
算法是：对可能性空间的结构化导航


当你能熟练做到：

- 看到问题先建 state
- 写出 transition 和 constraint
- 再选 BFS/DP/Greedy/...
你就进入了“决策系统工程”的思维层。


# Algorithm State → Pattern Cheat Sheet v0.1
（一页速查卡｜状态建模 → 算法选择）

---

## 0. 做题第一反应（强制流程）

永远先问 4 个问题：

1️⃣ state 是什么？（部分解）  
2️⃣ transition 是什么？（下一步如何生成）  
3️⃣ constraint 是什么？（哪些状态无效）  
4️⃣ objective 是什么？（最优/计数/存在）

然后再选算法。

---

# 1. 状态形态 → 算法族（最重要表）

| 你看到的 state 形态 | 典型特征 | 第一反应算法 |
|---|---|---|
| prefix / path | 在“构造解” | DFS / Backtracking |
| index / pointer | 在“扫描数组” | Two pointers / Sliding window |
| visited set | 状态组合爆炸 | Backtracking / Bitmask |
| graph node | 关系/路径 | BFS / DFS |
| weighted graph | 有 cost | Dijkstra |
| 子问题 | 可复用 | DP |
| 单调可行 | 可以 check(mid) | Binary search on answer |
| 区间 | 和区间相关 | Interval DP / Sweep line |
| 连续变量 | 数值优化 | Gradient / Numerical methods |

---

# 2. 目标 → 算法（第二速查表）

| 目标 | 算法 |
|---|---|
| 最少步数 | BFS |
| 最短路径（非负权） | Dijkstra |
| 最短路径（负权） | Bellman-Ford |
| 最优值（子问题） | DP |
| 所有方案 | Backtracking |
| 存在性 | DFS / BFS |
| 单调最优 | Binary search |
| 启发式目标 | A* |

---

# 3. 高频模式识别（面试最常见）

## Pattern A — Hash + Linear Scan
识别信号：
- 重复
- 频率
- 是否存在

state：
i + hash


---

## Pattern B — Two Pointers
识别信号：
- pair / triplet
- 排序后单调

state：
(l, r)


---

## Pattern C — Sliding Window
识别信号：
- 最长/最短子串
- 频率/统计

state：
(l, r, windowStats)


---

## Pattern D — Backtracking
识别信号：
- 输出所有组合
- 分支明显

state：
path


---

## Pattern E — BFS
识别信号：
- 最少操作
- 层级

state：
node


---

## Pattern F — DP
识别信号：
- 子问题重叠
- 最值/计数

state：
dp[i][j]


---

# 4. 状态建模最小原则（避免爆炸）

### 原则 1
能推导 → 不存

### 原则 2
必须判断的 → 必存

### 原则 3
state 越小 → 算法越强

---

# 5. transition 设计口诀

state -> action -> next state


问自己：

- 我有哪些 action？
- action 是否可剪枝？
- action 是否可排序？

---

# 6. 剪枝来源（效率关键）

| 来源 | 方法 |
|---|---|
| constraint | 提前 invalid |
| 上界估计 | branch & bound |
| 重复状态 | visited / memo |
| 排序 | 提前 break |

---

# 7. DP 本质速记

DP = DAG 上的路径计算


只要满足：

- 子问题
- 重叠
- 有顺序

就能 DP。

---

# 8. BFS vs DFS 一句话区分

| BFS | DFS |
|---|---|
| 找最短 | 找所有 |
| 队列 | 递归 |
| 层级 | 深度 |

---

# 9. Greedy 判断口诀

问：

局部最优能否交换成全局最优？


如果：

YES → greedy  
NO → DP / search

---

# 10. 面试时的“终极思维模板”

看到题，脑内自动走：

解空间是什么
↓
state 是什么
↓
transition 是什么
↓
constraint 是什么
↓
objective 是什么
↓
选算法


---

# 11. 最高级理解（你现在的位置）

算法 = 在状态空间中导航


再升级：

Decision system =
state + transition + constraint + objective


这已经是：

- AI
- RL
- 优化
- 控制系统

共同语言。

---

# 12. 一句话压轴

算法水平 = 状态建模能力


不是代码。
不是模板。
是：

> 你如何“表示世界”

# State Design Error Book v0.1
（状态建模错误手册｜算法卡住的真正原因）

> 目标：解释“为什么算法写不出来 / DP做不出来 / 会TLE / 剪枝无效”
> 核心：**不是算法不会，是 state 建错了。**

---

## 0. 总览：四类致命错误

| 错误类型 | 表现 | 本质原因 |
|---|---|---|
| State 过大 | TLE / 内存爆 | 信息冗余、维度爆炸 |
| State 不完整 | 转移写不出 | 关键约束未编码 |
| Transition 错误 | 解不对 / 死循环 | 状态变化规则不闭合 |
| Constraint 位置错误 | 剪枝无效 | 校验时机太晚或太早 |

---

# 1. 错误一：State 过大（State Explosion）

### 症状
- DFS 分支指数级
- DP 维度过高
- BFS 状态数巨大

### 典型反例
state = (path, visited, sum, count, history, ...)


### 正解思路
- 能推导 → 不存
- 可增量维护 → 不重复存
- 等价类合并 → 压缩

### 常见压缩手段
- bitmask 代替 visited set
- rolling array 降维
- 只存 index，不存 path（必要时再还原）

---

# 2. 错误二：State 信息不足（Underspecified State）

### 症状
- 转移写不出
- 重复状态无法识别
- 结果不稳定

### 典型反例
dp[i] # 但其实需要 dp[i][k]


### 判断标准
问：
> “两个看起来相同的 state，会不会导致不同未来？”

如果会 → 信息不足。

### 例
- 背包：
只用 i 不够，必须加 weight


---

# 3. 错误三：Transition 未闭合

### 症状
- 漏解
- 重复
- 死循环

### 正确 transition 要满足
从任一合法 state 出发

所有 next state 仍合法或可判定

能覆盖所有解空间


### 反例
- 没处理边界
- 忘记撤销 backtracking
- BFS 没加 visited

---

# 4. 错误四：Constraint 放错位置

### 剪枝三种时机

| 时机 | 作用 |
|---|---|
| 生成前 | 最强剪枝 |
| 生成时 | 常规 |
| 生成后 | 最弱 |

### 常见错误
先生成全部，再过滤


正确：
生成前判断可行


---

# 5. 错误五：把 DP 当公式推导

### 症状
- 背公式
- 写不出转移

### 正确方式
DP = 子问题图

问：
当前 state 依赖哪些更小 state？


不是：
dp[i] = ?


而是：

哪些状态能到 i？


---

# 6. 错误六：误把“搜索问题”当“DP问题”

### 判断方法

问：

state 是否会重复出现？


- 会 → DP / memo
- 不会 → DFS / BFS

---

# 7. 错误七：剪枝无效

### 原因

剪枝依赖：

上界估计


如果没有：

- 剪枝不会发生

### 常见错误
- 没排序
- 没计算 upper bound
- 没利用单调性

---

# 8. 错误八：复杂度估计错位

### 典型误判
看代码行数估复杂度


正确：

复杂度 = 状态数 × transition成本


---

# 9. 错误九：Representation 错误

这是最致命的。

### 表现
- 任何算法都慢
- DP / BFS / Greedy 全不对

### 本质
state 表示错了。

### 改法
换表示。

例：

| 原表示 | 新表示 |
|---|---|
| path | index |
| subset | bitmask |
| grid | graph |

---

# 10. 错误十：没有“目标函数”

### 表现
- 搜索盲目
- 无法优化

### 必须明确
objective


例：

- 最短
- 最小
- 最大
- 概率最高

---

# 11. 终极 Debug 模板（每次卡住用）

当算法写不出来，强制问：

### Q1
state 是否过大？

### Q2
state 是否缺信息？

### Q3
transition 是否完整？

### Q4
constraint 是否前置？

### Q5
目标是否可比较？

---

# 12. 一句话总结

算法失败的原因 ≠ 不会算法
算法失败的原因 = state 建模失败


---

# 13. 升级路线（v0.2）

下一步加入：

- DP 状态设计错误全集
- 剪枝理论（branch & bound）
- A* heuristic 设计
- representation learning（ML 对应）

---

# 最终结论

算法设计的核心不是 search
而是 representation


一旦 state 建对：

- BFS
- DP
- Greedy
- A*

都会自然出现。