# ADT、可表示性与算法层的层级边界说明

## 核心结论（定锚）

1. **ADT 描述“是什么”，而不是“如何算”。**  
2. **表示可以更换，但 ADT 不允许被破坏。**

ADT 属于数学抽象层级，**高于任何计算模型、表示选择与算法设计**。  
计算模型、表示与算法的合法性，必须以 ADT 规约为前提。

---

## 一、ADT 的层级定位（必须先澄清）

### 1. ADT 不是从计算模型中抽象出来的

**错误理解（常见但危险）：**

> 先有数据结构 / 表示 → 再抽象出 ADT

这是教学顺序的妥协，不是理论顺序。

**正确的层级关系是：**

数学对象（语义）
→ ADT（公理化规约）
→ 表示选择（可表示性）
→ 算法
→ 代码实现

ADT 本身：
- 不依赖有限性
- 不依赖离散化
- 不依赖精度
- 不依赖性能假设

---

### 2. ADT 的精确定义（语义层）

> **ADT 是对“可操作数学对象”的语义规约（semantic specification）**

它定义：

- **Value domain**：允许的状态集合  
- **Operations**：语义上允许的操作  
- **Invariants**：任何合法操作后必须保持的性质  
- **Equivalence**：什么时候两个状态算“同一个值”

ADT **不允许**涉及：
- 数据结构
- 存储方式
- 算法复杂度
- 数值精度
- 离散/连续取舍

---

## 二、原则 1：ADT 描述「是什么」，而不是「如何算」

### 1. 一个严格判断标准

> **只要描述中出现以下词汇，就已经不在 ADT 层：**  
> 数组、指针、矩阵、哈希、稀疏、浮点数、O(n)、缓存、并行

这些属于：
- 表示层
- 算法层
- 或实现层

---

### 2. 示例：Graph

#### ❌ 错误（混入实现）

> 图由邻接表表示，支持 BFS

这是 **表示 + 算法**，不是 ADT。

---

#### ✅ 正确（ADT 级）

**Graph ADT**

- Value domain：
  - 顶点集合 V
  - 边关系 E ⊆ V × V
- Operations：
  - neighbors(v)
  - add_edge(u, v)
- Invariants：
  - (u, v) ∈ E ⇒ u ∈ V 且 v ∈ V
- Equivalence：
  - 图同构视为等价

这里没有任何计算承诺。

---

### 3. 核心结论（1）

> **ADT 是语义合同，而不是计算方案。**  
> **它冻结“问题是什么”，而不关心“如何逼近”。**

---

## 三、原则 2：表示可以更换，但 ADT 不允许被破坏

### 1. 表示层的角色

表示层做的事情是：

> **为 ADT 寻找一个可被机器承载的具体状态编码**

即：

Representation ⊨ ADT

表示必须是 ADT 的一个合法模型（realization）。

---

### 2. 同一个 ADT，不同表示

以 **Set ADT** 为例：

ADT 语义：
- 无序
- 无重复
- membership 定义为真/假

可能的表示：
- bitset
- hash set
- sorted array

只要满足语义，它们仍然是 **同一个 ADT**。

---

### 3. 表示替换 ≠ 语义不变（关键风险）

**典型错误：**

> 为了性能换了表示，但仍假设原语义成立

#### 例子：Bloom Filter

- membership 允许假阳性
- 不再是严格集合

👉 这已经不是 Set ADT  
👉 而是 **ApproximateSet ADT**

如果不显式承认 ADT 变化，就会在系统层面埋雷。

---

### 4. 在 robustness / decision systems 中的严重后果

常见事故模式：

1. 为性能或规模换表示  
2. 表示引入近似 / 概率 / 截断  
3. ADT 不变量被削弱  
4. 上层算法仍假设原语义  
5. 极端条件下系统失效，且难以定位原因

问题 **不在算法**，而在 **ADT 被悄悄换了**。

---

## 四、一个可长期使用的合法性审计清单

> **任何一次表示替换，都必须回答：**

1. Value domain 是否发生变化？
2. 不变量是否仍然严格成立？
3. 等价关系是否被削弱或近似？

只要有一个答案是 **是**：

> **必须声明：ADT 已经不同了。**

---

## 五、可直接引用的定锚句（方法论级）

- **ADT 描述对象“是什么”，而表示与算法只决定“如何逼近它”。**
- **任何不保持 ADT 不变量的表示优化，都是语义变更，而不是工程细节。**
- **计算模型必须服从 ADT，而不是反过来。**

---

## 六、与后续层级的边界关系（简图）

[ 数学对象 / 语义 ]
↓
[ ADT（规约，不变量，等价） ]
↓
[ 可表示性（状态编码，近似，精度） ]
↓
[ 算法（复杂度，稳定性，收敛） ]
↓
[ 实现（语言，内存，硬件） ]

边界一旦混淆，问题就会从“工程问题”变成“系统性错误”。

---
