Methodological Decision Rules
算法范式选择的方法论决策规则

本节给出一组可重复、可自检、可迁移的决策规则，用于在完成业务建模与数学建模之后，确定合法且合适的算法范式。

这些规则不是“经验总结”，而是从建模链路中逻辑推出的必要判断。

Rule 0 · 前置条件（Precondition）

在进入算法范式选择之前，必须明确以下事实：

业务目标已被明确（优化 / 可行 / 探索 / 近似）

关键约束已被显式表达

数学模型已至少回答以下问题之一：

解是否存在？

结构是否自洽？

是否存在原则性不可行？

若上述条件不满足，算法范式选择本身是无意义的。

Rule 1 · 正确性等级优先原则

###（Correctness First）

判定问题：

如果程序给出错误结果，这种错误是否在原则上不可接受？

不可接受 → 必须依赖数学模型提供结构性保证

可接受（试错 / 探索） → 可直接采用搜索、仿真或启发式

方法论含义：

算法范式选择首先是一个正确性承诺问题，而不是效率问题。

Rule 2 · 局部决策冻结性规则

###（Greedy Permission Rule）

判定问题：

是否可以证明：一旦作出某个局部决策，其正确性在未来不会被推翻？

数学结构信号包括：

单调性

交换性质

matroid 结构

非负权约束

是 → 贪心算法被许可

否 / 无法证明 → 贪心算法被禁止

方法论含义：

贪心不是“大胆尝试”，而是结构被证明足够好的结果。

Rule 3 · 子问题独立性规则

###（Divide-and-Conquer Rule）

判定问题：

问题是否可以被拆分为若干相互独立的子问题，且合并过程不引入全局修正？

数学结构信号包括：

子问题之间无状态耦合

合并过程保持结构不变

子问题解的组合不需要回溯

是 → 分治算法被许可

否 → 分治会引入隐性错误

方法论含义：

分治失败，通常不是实现问题，而是独立性假设不成立。

Rule 4 · 状态封闭性与可枚举性规则

###（Dynamic Programming Rule）

判定问题：

是否存在一个有限、封闭、可枚举的状态表示，使得最优解可以由子状态最优解构成？

数学结构信号包括：

最优子结构

状态压缩可能性

历史可安全遗忘

是 → 动态规划被许可

否 → DP 将状态爆炸或逻辑错误

方法论含义：

动态规划的代价不是计算，而是你是否愿意为正确性支付状态空间。

Rule 5 · 结构不可证规则

###（Search Necessity Rule）

判定问题：

是否无法证明任何单调性、最优子结构或独立性？

是 → 搜索 / 回溯是唯一原则上安全的选择

否 → 搜索只是次优选择

方法论含义：

搜索不是“低级算法”，而是最低结构假设下的保底计算方式。

Rule 6 · 复杂性下限接受规则

###（Approximation Rule）

判定问题：

问题是否被证明为 NP-hard / 不可精确求解，且业务目标允许近似？

是 → 近似 / 启发式算法合法

否 → 近似属于方法论违规

方法论含义：

近似不是妥协，而是目标改变后的合理建模选择。

Rule 7 · 数学结构优先于算法经验

###（Structure Over Heuristics）

判定问题：

当前算法范式选择，是否可以被明确追溯到某个数学结构结论？

可以 → 方法论上合法

不可以 → 属于经验驱动或偶然成功

方法论含义：

一个算法“看起来有效”并不等价于“被结构许可”。

Rule 8 · 算法范式不是唯一的

###（Multi-Model Principle）

判定问题：

是否存在多个数学模型或结构视角？

是 → 允许并鼓励多算法范式并存

否 → 单一范式足矣

方法论含义：

多算法并存并不意味着认知混乱，而是多结构视角的自然结果。

总结性决策公式（可作为方法论定理）

你现在可以把整个判断过程压缩为一句公式：

数学结构
 + 正确性承诺
 + 可计算性约束
 ⇒ 合法算法范式集合


而不是：

问题
 ⇒ 想到什么算法用什么

最终定锚句（非常重要）

算法范式不是“解决问题的技巧分类”，
而是“在数学结构许可下，对计算风险与代价的制度化选择”。

到这里，你的整套思路已经具备三点特征：

自洽（逻辑不跳层）

可执行（能指导真实选择）

可辩护（能解释为什么不用某类算法）

如果你愿意，下一步就可以进入“反例层”：

用一个真实问题，刻意违反其中一条规则

看算法为什么必然失败