算法映射策略的三大「元选择」
The Three Meta-Choices of Algorithm Design

任何算法，都是这三类选择的一个具体组合。
你不需要再记 8 个维度，只要抓住这 3 个。

元选择一：结构信任程度

###（How much structure do I trust?）

这是最根本的一维，也是所有分支的源头。

核心问题

我愿意在多大程度上相信数学结构在未来仍然成立？

三个等级（你可以当成旋钮）
1️⃣ 低信任（不信结构）

不信单调性

不信最优子结构

不信局部可组合

👉 选择：

搜索

回溯

枚举

典型算法：DFS / 回溯 / SAT Solver

2️⃣ 中信任（信部分结构）

不信局部最优

但信“状态可封闭”

👉 选择：

动态规划

状态搜索

典型算法：Knapsack DP、Viterbi

3️⃣ 高信任（信强结构）

信单调性

信可冻结决策

👉 选择：

贪心

Dijkstra

Kruskal

典型算法：Greedy、Prim、Dijkstra

📌 一句话定理

算法范式 = 你愿意信结构到什么程度

元选择二：状态外化程度

###（How explicit do I make the state?）

这是算法形态差异的直接来源。

核心问题

我是否把数学状态显式存下来，还是按需生成？

三种模式
1️⃣ 显式状态（Externalized State）

状态表

完整缓存

明确维度

👉 优点：正确性强
👉 缺点：空间大

典型算法：DP、表填充

2️⃣ 半显式状态（Frontier-based）

只存边界

已决 / 未决分离

👉 优点：平衡
👉 缺点：结构依赖强

典型算法：Dijkstra、A*

3️⃣ 隐式状态（Implicit State）

不存状态

按需展开

👉 优点：空间小
👉 缺点：可能重复、慢

典型算法：DFS、IDDFS

📌 一句话定理

状态存不存，决定算法长什么样

元选择三：错误容忍与承诺水平

###（What kind of failure am I willing to accept?）

这是被严重低估，但极其关键的一维。

核心问题

如果算法“失败”，我希望它以什么方式失败？

三种承诺模式
1️⃣ 零错误容忍（Hard Correctness）

要么对

要么报错

👉 选择：

精确算法

可证明算法

典型算法：Bellman–Ford、Exact DP

2️⃣ 有条件正确（Conditional Correctness）

在假设成立时正确

假设破坏即失效

👉 选择：

贪心

Dijkstra

典型算法：Dijkstra（非负权）

3️⃣ 软失败（Soft Failure）

允许次优

允许近似

允许 anytime

👉 选择：

启发式

近似

随机化

典型算法：A*、Simulated Annealing

📌 一句话定理

算法不是“会不会错”，
而是“你允许它怎么错”

把一切压缩成一个「三轴空间」

你现在可以在脑中用这个三维空间来定位任何算法：

算法 = (结构信任, 状态外化, 错误承诺)

例子快速定位
算法	结构信任	状态外化	错误承诺
DFS	低	隐式	硬
DP	中	显式	硬
Dijkstra	高	半显式	条件
A*	高	半显式	软
为什么这个模型“够用”

因为它能反向生成算法：

你先决定
1️⃣ 信不信结构
2️⃣ 状态存多少
3️⃣ 错误怎么处理

👉 算法范式自然就落位了

你现在已经可以做的事（很重要）

你现在已经具备三种能力：

解释为什么某算法不适合某问题（不是凭感觉）

系统性比较算法差异（不是只比复杂度）

设计“新算法”作为映射组合（不是发明指令）

给你一句“可以写进方法论文”的终极句

算法设计，本质上是在数学结构、状态外化与错误承诺之间，
选择一个可执行的平衡点。