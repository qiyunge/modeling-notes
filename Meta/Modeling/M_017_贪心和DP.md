# M-ALG-002  
## 为什么 DP 能从模型推出，而贪心不能

---

## 0. 核心结论（定锚）

**动态规划（DP）是“模型驱动”的算法范式；  
贪心算法是“结构偶然成立”的算法范式。**

换句话说：

- **DP 的算法结构可以从数学模型中系统性推出**
- **贪心算法的策略只能先被提出，再事后证明正确**

---

## 1. 两种“算法生成逻辑”的根本差异

### 1.1 教材中常见的两条路径

**动态规划：**
数学模型
→ 状态定义
→ 递推关系
→ 算法


**贪心算法：**
数学模型
→ 猜一个局部选择规则
→ 算法
→ 正确性证明


这不是写作习惯差异，而是**理论本质差异**。

---

## 2. 为什么 DP 可以“从模型推出算法”

### 2.1 DP 的数学模型天然包含递归结构

一个典型 DP 模型，一旦写清楚，就隐含：

- 最优解定义（OPT）
- 子问题划分
- 子问题与原问题的组合关系

例如：
OPT(i) = 前 i 个元素的最优解


一旦这样建模：

- 子问题是强制存在的
- 子问题覆盖了全部可能情况
- 全局最优必然由子问题最优组成

👉 **递推式不是猜出来的，而是模型逼出来的。**

---

### 2.2 DP 不存在“策略选择问题”

DP 的核心思想不是：
> “该选哪个？”

而是：
> “我如何穷尽所有可能的选择？”

DP 的“策略”本质是：

> **枚举所有可能 → 取最优**

这不是一种选择策略，而是**对策略问题的消解**。

---

### 2.3 DP 的逻辑链是机械可复制的

数学模型
→ 定义状态空间
→ 写出递推关系
→ 确定计算顺序
→ 得到算法


这条链路可以被反复应用，是一种方法论。

---

## 3. 为什么贪心不能“从模型推出算法”

### 3.1 贪心模型中缺失的关键要素

贪心问题的数学模型通常只包含：

- 解空间
- 目标函数

但**不包含**：
- 局部最优 ⇒ 全局最优 的保证

数学模型本身**不指定构造顺序**。

---

### 3.2 贪心依赖“额外的结构性质”

贪心成立，必须满足额外条件，例如：

- 可交换性（exchangeability）
- 单调性（monotonicity）
- 拟阵结构（matroid）

这些性质具有以下特征：

- 不是模型自动给出的
- 无法通过机械步骤发现
- 只能通过证明事后确认

---

### 3.3 贪心的真实设计流程是反向的

数学模型
→ 猜一个局部选择规则
→ 构造算法
→ 证明该规则利用了某种隐藏结构


KT 中常见的证明方式：
- stays-ahead
- exchange argument

本质上都是**事后结构解释**。

---

## 4. DP vs 贪心：方法论对照表

| 维度 | 动态规划（DP） | 贪心（Greedy） |
|----|----|----|
| 是否从模型必然推出 | 是 | 否 |
| 是否需要猜策略 | 否 | 是 |
| 是否穷尽选择 | 是 | 否 |
| 正确性来源 | 最优子结构 | 交换 / 单调等附加性质 |
| 失败的主要原因 | 状态建模错误 | 策略选择错误 |
| 教材呈现顺序 | 模型 → 算法 | 算法 → 证明 |

---

## 5. 对 KT 教材“反直觉顺序”的解释

KT 在贪心算法中采用：

给出算法
→ 引入最优解 O
→ 通过比较证明算法最优


原因不是忽视模型，而是：

- 贪心策略无法由模型直接推出
- 数学结构只能在证明阶段被显性化
- 证明本身承担了“揭示结构”的角色

---

## 6. 本质总结（压轴）

**DP 是“模型即方法”；  
贪心是“模型 + 幸运的结构对齐”。**

进一步说：

- DP 的难点在于：**是否能正确建模**
- 贪心的难点在于：**是否值得相信某个直觉性策略**

---

## 7. 实用判断标准（重要）

面对一个新问题，先问自己：

> **如果我不用贪心，  
> 能否通过“穷尽 + 取最优”系统性解决？**

- 如果 **能** → DP 是主路线
- 如果 **不能 / 代价过高** → 才考虑贪心，但必须准备证明

---

**End of M-ALG-002**